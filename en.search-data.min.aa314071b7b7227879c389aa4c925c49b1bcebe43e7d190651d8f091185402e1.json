[{"id":0,"href":"/posts/java/%E5%BC%95%E7%94%A8%E6%8B%B7%E8%B4%9D-%E6%B5%85%E6%8B%B7%E8%B4%9D%E5%92%8C%E6%B7%B1%E6%8B%B7%E8%B4%9D/","title":"引用拷贝","section":"博客","content":"  引用拷贝：引用拷贝，就是拷贝引用地址。两个不同的引用指向同一个对象。\n  浅拷贝：浅拷贝会在堆上创建一个新的对象（区别于引用拷贝的一点）\n  如果属性是基本类型(int,double,long,boolean等)，拷贝的就是基本类型的值\n  如果属性是引用类型，拷贝的就是内存地址（即复制引用但不复制引用的对象）\n 注：String类型通过常量赋值时相当于基本数据类型，由于String为不可变对象，是无法修改原String的状态的，其会生成一个新的String对象\n     深拷贝 ：深拷贝会完全复制整个对象，包括这个对象所包含的内部对象。\n  图示：\n   案例：\n实现浅拷贝\n 在需要拷贝的类上实现 Cloneable 接口，并重写 clone() 方法。实现很简单，直接调用的是父类 Object 的 clone() 方法。 使用的时候调用实现类的clone方法  public class Address implements Cloneable{  private final String name;  // 省略构造函数、Getter\u0026amp;Setter方法  @Override  public Address clone() {  try {  return (Address) super.clone();  } catch (CloneNotSupportedException e) {  throw new AssertionError();  }  } }  public class Person implements Cloneable {  private Address address;  // 省略构造函数、Getter\u0026amp;Setter方法  @Override  public Person clone() {  try {  Person person = (Person) super.clone();  return person;  } catch (CloneNotSupportedException e) {  throw new AssertionError();  }  } } 测试 ：\nPerson person1 = new Person(new Address(\u0026#34;武汉\u0026#34;)); Person person1Copy = person1.clone(); // true System.out.println(person1.getAddress() == person1Copy.getAddress()); 从输出结构就可以看出， person1 的克隆对象和 person1 使用的仍然是同一个 Address 对象。\n如果改变该类的引用属性，克隆对象的引用属性也会随着改变。\n实现深拷贝\n 对 Person 类的 clone() 方法进行修改，连带着要把 Person 对象内部的 Address 对象一起复制。  @Override public Person clone() {  try {  Person person = (Person) super.clone();  person.setAddress(person.getAddress().clone());  return person;  } catch (CloneNotSupportedException e) {  throw new AssertionError();  } } 测试 ：\nPerson person1 = new Person(new Address(\u0026#34;武汉\u0026#34;)); Person person1Copy = person1.clone(); // false System.out.println(person1.getAddress() == person1Copy.getAddress()); 从输出结构就可以看出，虽然 person1 的克隆对象和 person1 包含的 Address 对象已经是不同的了。意味着深拷贝创建一个新的对象，是完全独立于原对象的，所以无论怎么修改属性，另一个对象中的属性也不会随着改变。\n实现引用拷贝\n Person person = new Person();  Person person1 = person; 无论是改变person还是person1的任何属性，都会跟着改变。\n"},{"id":1,"href":"/posts/algorithm/leetcode/leetcode142.%E7%8E%AF%E5%BD%A2%E9%93%BE%E8%A1%A8ii/","title":"Leet Code142.环形链表 Ii","section":"博客","content":"142. 环形链表 II #  给定一个链表，返回链表开始入环的第一个节点。 如果链表无环，则返回 null。\n如果链表中有某个节点，可以通过连续跟踪 next 指针再次到达，则链表中存在环。 为了表示给定链表中的环，评测系统内部使用整数 pos 来表示链表尾连接到链表中的位置（索引从 0 开始）。如果 pos 是 -1，则在该链表中没有环。注意：pos 不作为参数进行传递，仅仅是为了标识链表的实际情况。\n不允许修改 链表。\n示例 1：\n 输入：head = [3,2,0,-4], pos = 1\r输出：返回索引为 1 的链表节点\r解释：链表中有一个环，其尾部连接到第二个节点。 示例 2：\n 输入：head = [1,2], pos = 0\r输出：返回索引为 0 的链表节点\r解释：链表中有一个环，其尾部连接到第一个节点。 示例 3：\n 输入：head = [1], pos = -1\r输出：返回 null\r解释：链表中没有环。 提示：\n 链表中节点的数目范围在范围 [0, 104] 内 -105 \u0026lt;= Node.val \u0026lt;= 105 pos 的值为 -1 或者链表中的一个有效索引  **进阶：**你是否可以使用 O(1) 空间解决此题？\n题解 #  一般解 #  借助容器哈希表，空间复杂度O(N)\n难度不大，依次存入结点，返回重复的结点\n代码：\npublic ListNode detectCycle(ListNode head) {  ListNode cur = head;  Set\u0026lt;ListNode\u0026gt; set = new HashSet\u0026lt;\u0026gt;();  while (cur != null) {  if (!set.contains(cur)) {  set.add(cur);  } else {  return cur;  }  cur = cur.next;  }  return null; } 最优解 #  借助快慢指针，空间复杂度O(1)\n如果快慢指针相遇了且不为空，则说明有环，那要怎么找出入环点呢？\n结论：快慢指针相遇后，快指针回到head并且速度调为1且慢指针先走一步，当快慢指针再次相遇则为入环点。\n举个例子：\n不是证明，证明我也不懂，证明可以看下这篇帖子 单链表的相交以及有环无环问题（含数学证明）\n faster只在环内走一圈就相遇的情况：\nslower和faster都从起点出发：\nslower所走的距离为： D+S1\nfaster所走的距离为： D+S1+S2+S1 = D+2S1+S2\n又因为faster是slower的两倍，则有2（D+S1） = D+2S1+S2 解得： D = S2\n 因为个人习惯faster起点在head.next，所以第二次追赶的时候slower要先走一步\n 代码：\npublic static ListNode findLoopNode(ListNode head) {  if (head == null || head.next == null) {  return null;  }  ListNode faster = head.next;  ListNode slower = head;  while (faster != null \u0026amp;\u0026amp; faster.next != null \u0026amp;\u0026amp; faster != slower) {  faster = faster.next.next;  slower = slower.next;  }  // 说明快慢指针没有相遇 无环  if (faster == null || faster.next == null) {  return null;  }  // 快慢指针相遇 慢指针走一步 快指针回到head  slower = slower.next;  faster = head;  while (faster != slower) {  faster = faster.next;  slower = slower.next;  }  // 此时快慢指针相遇则为入环点  return faster; } "},{"id":2,"href":"/posts/algorithm/leetcode/leetcode148.%E6%8E%92%E5%BA%8F%E9%93%BE%E8%A1%A8/","title":"Leet Code148.排序链表","section":"博客","content":"148. 排序链表 #  给你链表的头结点 head ，请将其按 升序 排列并返回 排序后的链表 。\n示例 1：\n 输入：head = [4,2,1,3]\r输出：[1,2,3,4] 示例 2：\n 输入：head = [-1,5,3,4,0]\r输出：[-1,0,3,4,5] 示例 3：\n输入：head = []\r输出：[] 提示：\n 链表中节点的数目在范围 [0, 5 * 10 ^ 4] 内 -105 \u0026lt;= Node.val \u0026lt;= 105  进阶：你可以在 O(n log n) 时间复杂度和常数级空间复杂度下，对链表进行排序吗？\n题解 #  时间复杂度要求 O(n log n) 的话，只能是快速排序、归并排序和堆排序，而且要求时间复杂度要求 O(1)\n 数组的堆排空间复杂度是可以达到O(1)的\n 只能是快排和归并，并且是迭代法(自底向上)，因为递归的话也会占用O(log N)的系统栈空间\n这里选用递归的归并排序，迭代版的下次再补坑\n链表可以通过修改引用来更改节点顺序，merge过程无需像数组一样开辟额外空间；\n大体过程和数组归并差不多\n1、找中点分割\n 和数组的区别：链表找中点用到了快慢指针，当快指针停下时，慢指针指向中点位置，并且快指针初始指向的是head.next，简化了边界处理。\n 2、归并过程\n 和数组的区别：不需要开辟新的空间，只需要两个新指针，一个保存结果的head，一个做为归并时的临时指针。当归并过程，一边链表挂载完毕时，另一边不需要像数组那样通过while循环把剩下的依次复制，只需要挂上剩下结点的引用。\n public ListNode sortList(ListNode head) {  if (head == null || head.next == null) {  return head;  }  return process(head); }  public ListNode process(ListNode head) {  if (head == null || head.next == null) {  return head;  }  ListNode faster = head.next;  ListNode slower = head;  // 快慢指针找中点  while (faster != null \u0026amp;\u0026amp; faster.next != null) {  faster = faster.next.next;  slower = slower.next;  }  ListNode right = slower.next;  slower.next = null;  ListNode leftNode = process(head);  ListNode rightNode = process(right);  return merge(leftNode, rightNode); }  public ListNode merge(ListNode left, ListNode right) {  ListNode res = new ListNode(0);  // 需要用一个临时变量，避免res头指针改变  ListNode cur = res;  while (left != null \u0026amp;\u0026amp; right != null) {  if (left.val \u0026lt;= right.val) {  cur.next = left;  left = left.next;  } else {  cur.next = right;  right = right.next;  }  cur = cur.next;  }  // 剩下的直接挂上引用行  cur.next = left != null ? left : right;  return res.next; }  "},{"id":3,"href":"/posts/algorithm/leetcode/leetcode160.%E7%9B%B8%E4%BA%A4%E9%93%BE%E8%A1%A8/","title":"Leet Code160.相交链表","section":"博客","content":"160. 相交链表 #  给你两个单链表的头节点 headA 和 headB ，请你找出并返回两个单链表相交的起始节点。如果两个链表不存在相交节点，返回 null 。\n图示两个链表在节点 c1 开始相交**：**\n 题目数据 保证 整个链式结构中不存在环。\n注意，函数返回结果后，链表必须 保持其原始结构 。\n题解 #  注意：题目说的相交是指引用值相等，而不是val值相等\n使用哈希表肯定是能解的，但是空间复杂度不够好。所以不用哈希表，下面两个双指针解法的本质都是通过消除长度差，以同等的路程，两个指针同时开始遍历，两个链表如果相交，两个指针必然会相遇（相遇两指针相等）且不为null，为null说明不相交。\n双指针通俗易懂解法 #  public ListNode getIntersectionNode(ListNode headA, ListNode headB) {  // 这里判空可以不写  if (headA == null || headB == null) {  return null;  }  int lenA = 0;  int lenB = 0;  ListNode curA = headA;  ListNode curB = headB;  while (curA != null) {  lenA++;  curA = curA.next;  }  while (curB != null) {  lenB++;  curB = curB.next;  }  curA = headA;  curB = headB;  while(lenA \u0026gt; lenB) {  lenA--;  curA = curA.next;  }  while(lenB \u0026gt; lenA) {  lenB--;  curB = curB.next;  }  while (curA != curB) {  curB = curB.next;  curA = curA.next;  }  return curA; } 双指针优雅版 #  确实优雅，如果两个链表长度不相等，短链表比较快走到null，就接着走长链表的路，当长链表走到null时，接着走短链表的路。**本质上就是消除长度差。**leetcode上有个比较好的动图： public ListNode getIntersectionNode(ListNode headA, ListNode headB) {  ListNode curA = headA;  ListNode curB = headB;  while (curA != curB) {  curA = curA != null ? curA.next : headB;  curB = curB != null ? curB.next : headA;  }  return curA; } "},{"id":4,"href":"/posts/algorithm/%E5%9B%9E%E6%BA%AF%E6%97%B6%E7%9A%84%E5%8F%AF%E5%8F%98%E5%8F%82%E6%95%B0%E9%97%AE%E9%A2%98/","title":"回溯时的可变参数问题","section":"博客","content":"回溯时的可变参数问题\n到底什么时候传index什么时候传path\n其实传index和path的目的都是一样的\n出现错误是对Java的参数传递了解不够深\npath定义在全局变量\n当参数没有传path的时候\nprivate List\u0026lt;List\u0026lt;Integer\u0026gt;\u0026gt; res = new ArrayList\u0026lt;\u0026gt;(); private List\u0026lt;Integer\u0026gt; path = new ArrayList\u0026lt;\u0026gt;();  public void backTracking(int[] nums, int index) {  if (path.size() == nums.length) {  /* 这里拿的是全局变量path的直接引用，一但退出backTracking函数，res装的是直接引用，最后一个path就会被清空，导致答案不正确 */  path = new ArrayList\u0026lt;\u0026gt;(path);  res.add(path);  System.out.println(\u0026#34;backTracking函数中的path\u0026#34; + path);  return;  } \t// 省略无关代码 } 正确代码：\nprivate List\u0026lt;List\u0026lt;Integer\u0026gt;\u0026gt; res = new ArrayList\u0026lt;\u0026gt;(); private List\u0026lt;Integer\u0026gt; path = new ArrayList\u0026lt;\u0026gt;();  public void backTracking(int[] nums, int index) {  if (path.size() == nums.length) { \t// 不要改变全局path的引用  res.add(new ArrayList\u0026lt;\u0026gt;(path));  System.out.println(\u0026#34;backTracking函数中的path\u0026#34; + path);  return;  } \t// 省略无关代码 } 当参数有传path的时候\nprivate List\u0026lt;List\u0026lt;Integer\u0026gt;\u0026gt; res = new ArrayList\u0026lt;\u0026gt;(); private List\u0026lt;Integer\u0026gt; path = new ArrayList\u0026lt;\u0026gt;();  public void backTracking(int[] nums, List\u0026lt;Integer\u0026gt; path) {  if (path.size() == nums.length) {  /* 这里的path就不是全局的path了，因为path做了参数，所以会复制一份，所以没有影响 */  path = new ArrayList\u0026lt;\u0026gt;(path);  res.add(path);  System.out.println(\u0026#34;backTracking函数中的path\u0026#34; + path);  return;  } \t// 省略无关代码 } "},{"id":5,"href":"/posts/java/java%E5%AF%B9%E8%B1%A1%E5%BA%8F%E5%88%97%E5%8C%96%E4%B8%8E%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/","title":"Java对象序列化与反序列化","section":"博客","content":"概述 #  Java 提供了一种对象序列化的机制。用一个字节序列可以表示一个对象，该字节序列包含该对象的数据、对象的类型和对象中存储的属性等信息。字节序列写出到文件之后，相当于文件中持久保存了一个对象的信息。\n反之，该字节序列还可以从文件中读取回来，重构对象，对它进行反序列化。对象的数据、对象的类型和对象中存储的数据信息，都可以用来在内存中创建对象。\n简单来说：\n 序列化： 将数据结构或对象转换成二进制字节流的过程 反序列化：将在序列化过程中所生成的二进制字节流转换成数据结构或者对象的过程  对于 Java 这种面向对象编程语言来说，我们序列化的都是对象（Object）也就是实例化后的类(Class)，但是在 C++这种半面向对象的语言中，struct(结构体)定义的是数据结构类型，而 class 对应的是对象类型。\n维基百科：\n 序列化（serialization）在计算机科学的数据处理中，是指将数据结构或对象状态转换成可取用格式（例如存成文件，存于缓冲，或经由网络中发送），以留待后续在相同或另一台计算机环境中，能恢复原先状态的过程。依照序列化格式重新获取字节的结果时，可以利用它来产生与原始对象相同语义的副本。对于许多对象，像是使用大量引用的复杂对象，这种序列化重建的过程并不容易。面向对象中的对象序列化，并不概括之前原始对象所关系的函数。这种过程也称为对象编组（marshalling）。从一系列字节提取数据结构的反向操作，是反序列化（也称为解编组、deserialization、unmarshalling）。\n 综上：序列化的主要目的是通过网络传输对象或者说是将对象存储到文件系统、数据库、内存中。\n  ObjectOutputStream类 #  java.io.ObjectOutputStream 类，将Java对象的原始数据类型写出到文件,实现对象的持久存储。\n构造方法 #   public ObjectOutputStream(OutputStream out)： 创建一个指定OutputStream的ObjectOutputStream。  构造举例，代码如下：\nFileOutputStream fileOut = new FileOutputStream(\u0026#34;employee.txt\u0026#34;); ObjectOutputStream out = new ObjectOutputStream(fileOut); 序列化操作 #   一个对象要想序列化，必须满足两个条件:    该类必须实现java.io.Serializable 接口，Serializable 是一个标记接口，不实现此接口的类将不会使任何状态序列化或反序列化，会抛出NotSerializableException 。\n  该类的所有属性必须是可序列化的。如果有一个属性不需要可序列化的，则该属性必须注明是瞬态的，使用transient 关键字修饰。\n  被static修饰的属性也不会被序列化(因为static属性不属于对象)\n 注意：\n  transient 只能修饰变量，不能修饰类和方法。\n  transient 修饰的变量，在反序列化后变量值将会被置成类型的默认值。例如，如果是修饰 int 类型，那么反序列后结果就是 0。\n     public class Employee implements java.io.Serializable {  public String name;  public String address;  public transient int age; // transient瞬态修饰成员,不会被序列化  public void addressCheck() {  System.out.println(\u0026#34;Address check : \u0026#34; + name + \u0026#34; -- \u0026#34; + address);  } } 2.写出对象方法\n public final void writeObject (Object obj) : 将指定的对象写出。  public class SerializeDemo{  public static void main(String [] args) {  Employee e = new Employee();  e.name = \u0026#34;zhangsan\u0026#34;;  e.address = \u0026#34;beiqinglu\u0026#34;;  e.age = 20;  try {  // 创建序列化流对象  ObjectOutputStream out = new ObjectOutputStream(new FileOutputStream(\u0026#34;employee.txt\u0026#34;));  // 写出对象  out.writeObject(e);  // 释放资源  out.close();  fileOut.close();  System.out.println(\u0026#34;Serialized data is saved\u0026#34;); // 姓名，地址被序列化，年龄没有被序列化。  } catch(IOException i) {  i.printStackTrace();  }  } } 输出结果： Serialized data is saved ObjectInputStream类 #  ObjectInputStream反序列化流，将之前使用ObjectOutputStream序列化的原始数据恢复为对象。\n构造方法 #   public ObjectInputStream(InputStream in)： 创建一个指定InputStream的ObjectInputStream。  反序列化操作1 #  如果能找到一个对象的class文件，我们可以进行反序列化操作，调用ObjectInputStream读取对象的方法：\n public final Object readObject () : 读取一个对象。  public class DeserializeDemo {  public static void main(String [] args) {  Employee e = null;  try {  // 创建反序列化流  FileInputStream fileIn = new FileInputStream(\u0026#34;employee.txt\u0026#34;);  ObjectInputStream in = new ObjectInputStream(fileIn);  // 读取一个对象  e = (Employee) in.readObject();  // 释放资源  in.close();  fileIn.close();  }catch(IOException i) {  // 捕获其他异常  i.printStackTrace();  return;  }catch(ClassNotFoundException c) {  // 捕获类找不到异常  System.out.println(\u0026#34;Employee class not found\u0026#34;);  c.printStackTrace();  return;  }  // 无异常,直接打印输出  System.out.println(\u0026#34;Name: \u0026#34; + e.name); // zhangsan  System.out.println(\u0026#34;Address: \u0026#34; + e.address); // beiqinglu  System.out.println(\u0026#34;age: \u0026#34; + e.age); // 0  } } 对于JVM可以反序列化对象，它必须是能够找到class文件的类。如果找不到该类的class文件，则抛出一个 ClassNotFoundException 异常。\n反序列化操作2 #  **另外，当JVM反序列化对象时，能找到class文件，但是class文件在序列化对象之后发生了修改，那么反序列化操作也会失败，抛出一个InvalidClassException异常。**发生这个异常的原因如下：\n 该类的序列版本号与从流中读取的类描述符的版本号不匹配 该类包含未知数据类型 该类没有可访问的无参数构造方法  Serializable 接口给需要序列化的类，提供了一个序列版本号。serialVersionUID 该版本号的目的在于验证序列化的对象和对应类是否版本匹配。\npublic class Employee implements java.io.Serializable {  // 加入序列版本号  private static final long serialVersionUID = 1L;  public String name;  public String address;  // 添加新的属性 ,重新编译, 可以反序列化,该属性赋为默认值.  public int eid;   public void addressCheck() {  System.out.println(\u0026#34;Address check : \u0026#34; + name + \u0026#34; -- \u0026#34; + address);  } } 案例：序列化集合 #   将存有多个自定义对象的集合序列化操作，保存到list.txt文件中。 反序列化list.txt ，并遍历集合，打印对象信息。  案例分析 #   把若干学生对象 ，保存到集合中。 把集合序列化。 反序列化读取时，只需要读取一次，转换为集合类型。 遍历集合，可以打印所有的学生信息  案例实现 #  public class SerTest {  public static void main(String[] args) throws Exception {  // 创建 学生对象  Student student = new Student(\u0026#34;老王\u0026#34;, \u0026#34;laow\u0026#34;);  Student student2 = new Student(\u0026#34;老张\u0026#34;, \u0026#34;laoz\u0026#34;);  Student student3 = new Student(\u0026#34;老李\u0026#34;, \u0026#34;laol\u0026#34;);   ArrayList\u0026lt;Student\u0026gt; arrayList = new ArrayList\u0026lt;\u0026gt;();  arrayList.add(student);  arrayList.add(student2);  arrayList.add(student3);  // 序列化操作  // serializ(arrayList);   // 反序列化  ObjectInputStream ois = new ObjectInputStream(new FileInputStream(\u0026#34;list.txt\u0026#34;));  // 读取对象,强转为ArrayList类型  ArrayList\u0026lt;Student\u0026gt; list = (ArrayList\u0026lt;Student\u0026gt;)ois.readObject();   for (int i = 0; i \u0026lt; list.size(); i++ ){  Student s = list.get(i);  System.out.println(s.getName()+\u0026#34;--\u0026#34;+ s.getPwd());  }  }   private static void serializ(ArrayList\u0026lt;Student\u0026gt; arrayList) throws Exception {  // 创建 序列化流  ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream(\u0026#34;list.txt\u0026#34;));  // 写出对象  oos.writeObject(arrayList);  // 释放资源  oos.close();  } } "},{"id":6,"href":"/posts/java/scanner%E7%9A%84nextline%E8%AF%BB%E5%8F%96%E4%B8%BA%E7%A9%BA/","title":"Scanner的next Line()读取为空","section":"博客","content":"在一次读取题目的输入样例时，发现使用 Scanner 的 readLine() 方法读取到的数据为空。\n原因是我在读取第一行数据的时候使用的是 readInt() 读取两个数字，而下面的 01矩阵使用是 readLine() 读取。\n那么为什么会出现读取为空的现象呢？\n3 4\r0001\r0011\r0110 Scanner 读取方式的区别 #  先来弄清楚 Scanner 常用几种读取方式的区别：\nnext()：会自动消去有效字符前的空格，只返回输入的字符。遇到有效字符后的空格就停止，所以读取输入后光标定在同一行。\nnextInt()/nextDouble()/nextFloat()：跟 next() 方法是一样的，只不过读取后会自动转换成相应的数据类型。\nnextLine()：按行读取，可以读到空格，以回车结束(即读取到换行\\n的末尾)。读取输入后，光标定位在下一行。\nScanner read = new Scanner(System.in);  System.out.print(\u0026#34;输入:\u0026#34;); String str1 = read.nextLine(); System.out.println(\u0026#34;输出:\u0026#34;+ str1);  System.out.print(\u0026#34;输入:\u0026#34;); String str2 = read.next(); System.out.println(\u0026#34;输出:\u0026#34;+ str2);  System.out.print(\u0026#34;输入:\u0026#34;); int n = read.nextInt(); System.out.println(\u0026#34;输出:\u0026#34;+ n); 控制台输出效果：\n 我们再将 nextLine() 读取放到 next() 后：\n发现 nextLine() 没有读取任何输入直接输出了。\n 其实原因上面也已经说了，如果在 nextLine() 之前用的是 next()/nextInt()... 方法读取，那么读取完后光标其实是定位在同一行行尾的，也就是换行符并没有被读取，如果这时在调用 nextLine() 方法读取，它读取到的就仅仅是一个换行符，而没有其他数据。\n解决方法 #  1、在使用 nextLine() 读取想要的数据前先调用一次 nextLine() ，这样留在缓冲区的换行符就会被处理掉，这时第二个 nextLine() 就可以正常读取到数据。\n2、避免在 nextLine() 之前调用 nextInt() 等方法，可以统一使用 nextLine() 来读取数据，之后再进行类型转换。\n"},{"id":7,"href":"/posts/java/string-stringbuffer-%E5%92%8C-stringbuilder-%E7%9A%84%E5%8C%BA%E5%88%AB%E6%98%AF%E4%BB%80%E4%B9%88-string-%E4%B8%BA%E4%BB%80%E4%B9%88%E6%98%AF%E4%B8%8D%E5%8F%AF%E5%8F%98%E7%9A%84/","title":"String String Buffer 和 String Builder 的区别是什么 String 为什么是不可变的","section":"博客","content":"可变性\n简单的来说：String 类中使用 final 关键字修饰字符数组来保存字符串，所以String 对象是不可变的。\npublic final class String implements java.io.Serializable, Comparable\u0026lt;String\u0026gt;, CharSequence {  private final char value[]; \t//... }  🐛 修正 ： 我们知道被 final 关键字修饰的类不能被继承，修饰的方法不能被重写，修饰的变量是基本数据类型则值不能改变，修饰的变量是引用类型则不能再指向其他对象。因此，final 关键字修饰的数组保存字符串并不是 String 不可变的根本原因，因为这个数组保存的字符串是可变的（final 修饰引用类型变量的情况）。\nString 真正不可变有下面几点原因：\n 保存字符串的数组被 final 修饰且为私有的，并且String 类没有提供/暴露修改这个字符串的方法。 String 类被 final 修饰导致其不能被继承，进而避免了子类破坏 String 不可变。  相关阅读： 如何理解 String 类型值的不可变？ - 知乎提问 (opens new window)\n补充（来自 issue 675 (opens new window)）：在 Java 9 之后，String 、StringBuilder 与 StringBuffer 的实现改用 byte 数组存储字符串 private final byte[] value\n StringBuilder 与 StringBuffer 都继承自 AbstractStringBuilder 类，在 AbstractStringBuilder 中也是使用字符数组保存字符串，不过没有使用 final 和 private 关键字修饰，最关键的是这个 AbstractStringBuilder 类还提供了很多修改字符串的方法比如 append 方法。\nabstract class AbstractStringBuilder implements Appendable, CharSequence {  char[] value;  public AbstractStringBuilder append(String str) {  if (str == null)  return appendNull();  int len = str.length();  ensureCapacityInternal(count + len);  str.getChars(0, len, value, count);  count += len;  return this;  }  //... } 线程安全性\nString 中的对象是不可变的，也就可以理解为常量，线程安全。AbstractStringBuilder 是 StringBuilder 与 StringBuffer 的公共父类，定义了一些字符串的基本操作，如 expandCapacity、append、insert、indexOf 等公共方法。StringBuffer 对方法加了同步锁或者对调用的方法加了同步锁，所以是线程安全的。StringBuilder 并没有对方法进行加同步锁，所以是非线程安全的。\n性能\n每次对 String 类型进行改变的时候，都会生成一个新的 String 对象，然后将指针指向新的 String 对象。StringBuffer 每次都会对 StringBuffer 对象本身进行操作，而不是生成新的对象并改变对象引用。相同情况下使用 StringBuilder 相比使用StringBuffer 仅能获得 10%~15% 左右的性能提升，但却要冒多线程不安全的风险。\n对于三者使用的总结：\n 操作少量的数据: 适用 String 单线程操作字符串缓冲区下操作大量数据: 适用 StringBuilder 多线程操作字符串缓冲区下操作大量数据: 适用 StringBuffer  "},{"id":8,"href":"/posts/java/%E7%A7%BB%E4%BD%8D%E8%BF%90%E7%AE%97%E7%AC%A6-val--2--val--1-%E7%9A%84%E6%83%85%E5%86%B5/","title":"移位运算符 Val 2 ! Val 1 的情况","section":"博客","content":"在写堆排序用移位运算的时候发现执行报了个数组索引越界\n 打印了下才发现 -1 \u0026raquo; 1 并不等于0而是等于1\n 原码 补码 右移一位 结果（原码） -1 = 1000 0001， 1111 1111， 1111 1111 -1 -2 = 1000 0010， 1111 1110， 1111 1111 -1 -3 = 1000 0011， 1111 1101， 1111 1110 -2 -4 = 1000 0100， 1111 1100， 1111 1110 -2 -5 = 1000 0101， 1111 1011， 1111 1101 -3 -6 = 1000 0110， 1111 1010， 1111 1101 -3 对于 val / 2 != val \u0026raquo; 1的原因是：val为负数且为奇数或者正数移位数超过类型最大位数溢出为负。\n所以用移位运算代替乘除要考虑好数据的情况\n"},{"id":9,"href":"/posts/redis/redis/","title":"Redis","section":"博客","content":"Redis 基础 #  概念 #  数据类型 #  通用命令 #  Jedis #  Redis 高级 #  持久化 #  持久化简介 #  RDB #  （Redis DataBase）\nsave指令 #    命令\nsave   手动指定一次保存操作\n  ​\tsave指令相关配置\n   dbfilename dump.rdb\n说明：设置本地数据库文件名，默认值为 dump.rdb经验：通常设置为dump-端口号.rdb\n  dir\n说明：设置存储.rdb文件的路径\n经验：pwd命令显示当前目录绝对路径（填写这个路径），通常设置成存储空间较大的目录中，目录名称data\n  dbcompression yes\n说明：设置存储至本地数据库时是否压缩数据，默认为 yes，采用 LZF 压缩\n经验：通常默认为开启状态，如果设置为no，可以节省 CPU 运行时间，但会使存储的文件变大（巨大）\n  rdbchecksum yes\n说明：设置是否进行RDB文件格式校验，该校验过程在写文件和读文件过程均进行\n经验：通常默认为开启状态，如果设置为no，可以节约读写性过程约10%时间消耗，但是存储一定的数据损坏风险\n  save指令工作原理\n 注意：save指令的执行会阻塞当前Redis服务器，直到当前RDB过程完成为止，有可能会造成长时间阻塞，线上环境不建议使用。\nbgsave指令 #    命令\nbgsave   作用\n手动启动后台保存操作，但不是立即执行，可以若执行成功可在日志文件看到信息\n   bgsave指令相关配置\n bgsave指令工作原理\n 注意： bgsave命令是针对save阻塞问题做的优化。Redis内部所有涉及到RDB操作应该都采用bgsave的方式，save命令可以放弃使用。\nsave配置(自动配置) #    配置\nsave second changes   作用 满足限定时间范围内key的变化数量达到指定数量即进行持久化\n  参数 second：监控时间范围 changes：监控key的变化量\n  位置 在conf文件中进行配置\n  范例\nsave second changes\rsave 900 1\rsave 300 10\rsave 60 10000    save配置原理\n RDB三种启动方式对比 #     方式 save指令 bgsave指令 save配置     读写 同步 异步 异步   阻塞客户端指令 是 否 否   额外内存消耗 否 是 是   启动新进程 否 是 是    RDB优缺点 #   优点  RDB是一个紧凑压缩的二进制文件，存储效率较高(这是二进制存储的特点) RDB内部存储的是redis在某个时间点的数据快照，非常适合用于数据备份，全量复制等场景 RDB恢复数据的速度要比AOF快很多 应用：服务器中每X小时执行bgsave备份，并将RDB文件拷贝到远程机器中，用于灾难恢复。   缺点  大数据量下的IO性能较低 RDB方式无论是执行指令还是利用配置，无法做到实时持久化，具有较大的可能性丢失数据 bgsave指令每次运行要执行fork操作创建子进程，要牺牲掉一些性能 Redis的众多版本中未进行RDB文件格式的版本统一，有可能出现各版本服务之间数据格式无法兼容现象    AOF #  （AppendOnly File）\n写的三种策略 #   always(每次） 每次写入操作均同步到AOF文件中，数据零误差，性能较低，不建议使用。 everysec（每秒） 每秒将缓冲区中的指令同步到AOF文件中，数据准确性较高，性能较高，建议使用，也是默认配置 在系统突然宕机的情况下丢失1秒内的数据 no（系统控制） 由操作系统控制每次同步到AOF文件的周期，整体过程不可控  AOF功能开启\n  配置\nappendonly yes|no   作用 是否开启AOF持久化功能，默认为不开启状态\n  配置\nappendfsync always|everysec|no   作用\nAOF写数据策略\n   AOF重写 #   RDB-AOF混合持久化 #  redis4.0版本开始允许使用RDB-AOF混合持久化的方式\n结合了两者的优点通过aof-use-rdb-preamble配置项可以打开混合开关。\n这里阿里云的文档，redis官方的外网文档才有更新\n https://developer.aliyun.com/article/193034\n https://redis.io/topics/persistence\nRDB与AOF的区别 #  持久化应用场景 #  事务 #   什么是redis事务？\nredis事务就是一个命令执行的队列，将一系列预定义命令包装成一个整体（一个队列）。当执行时，一次性 按照添加顺序依次执行，中间不会被打断或者干扰。 一个队列中，一次性、顺序性、排他性的执行一系列命令。\n注意：区别于关系型数据库原子性问题\n 事务基本操作 #    开启事务\nmulti  作用 设定事务的开启位置，此指令执行后，后续的所有指令均加入到事务队列中    执行事务 （executive）\nexec   作用 设定事务的结束位置，同时执行事务。与multi成对出现，成对使用\n 注意：加入事务的命令暂时进入到任务队列中，并没有立即执行，只有执行exec命令才开始执行\n     取消事务\ndiscard   作用\n事务定义过程中发现出了问题，清空事务队列中保存的所有命令，终止当前事务的定义，发生在multi之后，exec之前\n     Redis事务是否满足原子性 #  {% post_link 关于Redis事务是否满足原子性 %}\n锁 #  监视锁 #  业务场景\n天猫双11热卖过程中，对已经售罄的货物追加补货，4个业务员都有权限进行补货。补货的操作可能是一系 列的操作，牵扯到多个连续操作，如何保障不会重复操作？\n业务分析\n 多个客户端有可能同时操作同一组数据，并且该数据一旦被操作修改后，将不适用于继续操作 在操作之前锁定要操作的数据，一旦发生变化，终止当前操作  解决方案\n  对 key 添加监视锁，开启事务multi后在执行exec前如果key发生了变化，终止该事务执行\nwatch key1 [key2......]   取消对所有 key 的监视\nunwatch   分布式锁 #  业务场景\n天猫双11热卖过程中，对已经售罄的货物追加补货，且补货完成。客户购买热情高涨，3秒内将所有商品购买完毕。本次补货已经将库存全部清空，如何避免最后一件商品不被多人同时购买？【超卖问题】\n业务分析\n 使用watch监控一个key有没有改变已经不能解决问题，此处要监控的是具体数据 虽然redis是单线程的，但是多个客户端对同一数据同时进行操作时，如何避免不被同时修改？  解决方案\n  使用 setnx 设置一个公共锁\nsetnx lock-key value 利用setnx命令的返回值特征，有值则返回设置失败，无值则返回设置成功\n  对于返回设置成功的，拥有控制权，进行下一步的具体业务操作\n  对于返回设置失败的，不具有控制权，排队或等待操作完毕通过del操作释放锁\n    解锁\ndel lock-name  注意：上述解决方案是一种设计概念，依赖规范保障，具有风险性\n   分布式锁改良（解决死锁） #  业务场景\n依赖分布式锁的机制，某个用户操作时对应客户端宕机，且此时已经获取到锁。如何解决？\n业务分析\n 由于锁操作由用户控制加锁解锁，必定会存在加锁后未解锁的风险 需要解锁操作不能仅依赖用户控制，系统级别要给出对应的保底处理方案  解决方案\n使用 expire 为锁key添加时间限定，到时不释放，放弃锁\nsetnx lock-key value\rexpire lock-key second pexpire lock-key milliseconds 由于操作通常都是微秒或毫秒级，因此该锁定时间不宜设置过大。具体时间需要业务测试后确认。\n 例如：持有锁的操作最长执行时间127ms，最短执行时间7ms。 测试百万次最长执行时间对应命令的最大耗时，测试百万次网络延迟平均耗时 锁时间设定推荐：最大耗时120%+平均网络延迟110% 如果业务最大耗时\u0026laquo;网络平均延迟，通常为2个数量级，取其中单个耗时较长即可  Redssion #  过期/删除策略 #  过期数据 #  数据特征:\nRedis是一种内存级数据库，所有数据均存放在内存中，内存中的数据可以通过TTL指令获取其状态\n XX ：具有时效性的数据 -1 ：永久有效的数据 -2 ：已经过期的数据 或 被删除的数据 或 未定义的数据  但是考虑到CPU占用问题这些过期的数据实际上还存在内存中\n过期策略 #   又叫key过期淘汰机制\n这里讲的都是具有时效性的过期数据，与逐出策略不同\n  删除策略的目标：\n 在内存占用与CPU占用之间寻找一种平衡，顾此失彼都会造成整体redis性能的下降，甚至引发服务器宕机或内存泄露\n 定时删除 #   创建一个定时器，当key设置有过期时间，且过期时间到达时，由定时器任务立即执行对键的删除操作 优点：节约内存，到时就删除，快速释放掉不必要的内存占用 缺点：CPU压力很大，无论CPU此时负载量多高，均占用CPU，会影响redis服务器响应时间和指令吞吐量 总结：用处理器性能换取存储空间（时间换空间）   惰性删除 #    数据到达过期时间，不做处理。等下次访问该数据时\n  如果未过期，返回数据\n 由expireIfNeeded()函数实现\n   发现已过期，删除，返回不存在\n  优点：节约CPU性能，发现必须删除的时候才删除\n  缺点：内存压力很大，出现长期占用内存的数据\n  总结：用存储空间换取处理器性能 （空间换时间）\n   定期删除 #   定期删除策略是定时删除策略和惰性删除策略的一种整合折中方案。\n   W可以自己定义conf配置文件\n上图只画出了8个db，每个db里有一个expires\n轮询执行：\n​\tsertverCron() ：对整个Redis存储空间\n​\tdatabasesCron()：对每一个database库（expires[]）\n​\tactiveExpireCycle()：对expires[]里的每一个key检测\n  周期性轮询redis库中的时效性数据，采用随机抽取的策略，利用过期数据占比的方式控制删除频度 特点1：CPU性能占用设置有峰值，检测频度可自定义设置 特点2：内存压力不是很大，长期占用内存的冷数据会被持续清理 总结：周期性抽查存储空间 （随机抽查，重点抽查(一轮中删除key数量比较多，循环该过程)）  删除策略比对 #    注意：Redis服务器使用的是惰性删除策略和定期删除策略。\n 逐出策略 #      redis.conf #      高级数据类型 #  Bitmaps #    获取指定key对应偏移量上的bit值\ngetbit key offset   设置指定key对应偏移量上的bit值，value只能是1或0\nsetbit key offset value   对指定key按位进行交、并、非、异或操作，并将结果保存到destKey中\n and：交 or：并 not：非 xor：异或    统计指定key中1的数量\nbitop op destKey key1 [key2...]\rbitcount key [start end]   业务场景\n  HyperLogLog #  基数\n 基数是数据集去重后元素个数 HyperLogLog 是用来做基数统计的，运用了LogLog的算法  {1, 3, 5, 7, 5, 7, 8} 基数集： {1, 3, 5 ,7, 8} 基数：5 {1, 1, 1, 1, 1, 7, 1} 基数集： {1,7} 基数：2\n基于LogLog算法\n基本操作\n  添加数据\npfadd key element [element ...]   统计数据\npfcount key [key ...]   合并数据\npfmerge destkey sourcekey [sourcekey...]   相关说明\n 用于进行基数统计，不是集合，不保存数据，只记录数量而不是具体数据 核心是基数估算算法，最终数值存在一定误差 误差范围：基数估计的结果是一个带有 0.81% 标准错误的近似值 耗空间极小，每个hyperloglog key占用了12K的内存用于标记基数 pfadd命令不是一次性分配12K内存使用，会随着基数的增加内存逐渐增大 Pfmerge命令合并后占用的存储空间为12K，无论合并之前数据量多少  GEO #    基本操作\n  添加坐标点\ngeoadd key longitude latitude member [longitude latitude member ...]\rgeoradius key longitude latitude radius m|km|ft|mi [withcoord] [withdist] [withhash] [count count]   获取坐标点\ngeopos key member [member ...]\rgeoradiusbymember key member radius m|km|ft|mi [withcoord] [withdist] [withhash] [count count]   计算坐标点距离\ngeodist key member1 member2 [unit]   计算经纬度\ngeohash key member [member ...]   Redis 集群 #  主从复制 #   主从复制是哨兵和 cluster 实施的基础，是高可用的基石\n 单机redis的风险与问题 #   问题1.机器故障  现象：硬盘故障、系统崩溃 本质：数据丢失，很可能对业务造成灾难性打击 结论：基本上会放弃使用redis.   问题2.容量瓶颈  现象：内存不足，从16G升级到64G，从64G升级到128G，无限升级内存 本质：穷，硬件条件跟不上 结论：放弃使用redis 结论：    为了避免单点Redis服务器故障，准备多台服务器，互相连通。将数据复制多个副本保存在不同的服务器上，连接在一起，并保证数据是同步的。即使有其中一台服务器宕机，其他服务器依然可以继续提供服务，实现Redis的高可用，同时实现数据冗余备份。\n 解决方案    Redis 3之前是一对多\n  主从复制的作用 #   读写分离：master写、slave读，提高服务器的读写负载能力 负载均衡：基于主从结构，配合读写分离，由slave分担master负载，并根据需求的变化，改变slave的数量，通过多个从节点分担数据读取负载，大大提高Redis服务器并发量与数据吞吐量 故障恢复：当master出现问题时，由slave提供服务，实现快速的故障恢复 数据冗余：实现数据热备份，是持久化之外的一种数据冗余方式 高可用基石：基于主从复制，构建哨兵模式与集群，实现Redis的高可用方案  主从复制工作流程 #  主从复制过程大体可以分为3个阶段\n 建立连接阶段（即准备阶段） #  主从连接\n从\u0026ndash;\u0026gt;主(从连接主)\n  第八步是设置权限是可选的，因为Redis一般是对内服务，不对外提供功能，安全性较高\n Redis 5.0 之前使用 slaveof（之后使用replicaof 命令）\n  方式一：从客户端发送命令\nslaveof \u0026lt;masterip\u0026gt; \u0026lt;masterport\u0026gt;\rslaveof 127.0.0.1 6379   方式二：启动从服务器参数\nredis-server -slaveof \u0026lt;masterip\u0026gt; \u0026lt;masterport\u0026gt;\rredis-server redis-6379.conf --slaveof 127.0.0.1 6379   方式三：从服务器配置（配置文件）\nslaveof \u0026lt;masterip\u0026gt; \u0026lt;masterport\u0026gt;   slave系统信息\n master_link_down_since_secondsi masterhost masterport    master系统信息\n slave_listening_port(多个)    主从断开(从客户端发)\nslaveof no one  注意：slave断开连接后，不会删除已有数据，只是不再接受master发送的数据\n   授权访问\n  master客户端发送命令设置密码\nrequirepass \u0026lt;password\u0026gt;   master配置文件设置密码\nconfig set requirepass \u0026lt;password\u0026gt; config get requirepass   slave客户端发送命令设置密码\nauth \u0026lt;password\u0026gt;   slave配置文件设置密码\nmasterauth \u0026lt;password\u0026gt;   slave启动服务器设置密码\nredis-server –a \u0026lt;password\u0026gt;   主从连接成功后slave从服务器的日志信息\n 主从连接成功后master主服务器的日志信息\n 数据同步阶段 #     总结下缓冲区：replication buffer存放的东西\n  master执行rdb bgsave产生snapshot的期间的数据更新操作\n  master发送rdb到slave网络传输期间的数据更新操作\n  slave load rdb文件把数据恢复到内存的期间的数据更新操作\n  命令传播阶段 #   实时保持数据同步，会启动增量复制\n  当master数据库状态被修改后，导致主从服务器数据库状态不一致，此时需要让主从数据同步到一致的状态，同步的动作称为命令传播 master将接收到的数据变更命令发送给slave，slave接收命令后执行命令  出现断网现象问题 #   网络闪断闪连\t忽略 短时间网络中断 增量复制 长时间网络中断 全量复制  增量复制的三个核心要素 #   服务器的运行 id（run id） 主服务器的复制积压缓冲区 主从服务器的复制偏移量  1、run id\n ●概念：服务器运行ID是每一台服务器每次运行的身份识别码，一台服务器多次运行可以生成多个运行id\n●组成：运行id由40位字符组成，是一个随机的十六进制字符 例如：fdc9ff13b9bbaab28db42b3d50f852bb5e3fcdce\n●作用：运行id被用于在服务器间进行传输，识别身份。如果想两次操作均对同一台服务器进行，必须每次操作携带对应的运行id，用于对方识别\n● 实现方式：运行id在每台服务器启动时自动生成的，master在首次连接slave时，会将自己的运行ID发送给slave，slave保存此ID，通过info Server命令，可以查看节点的runid\n 2、复制积压缓冲区\n ●概念：repl_backlog_buffer，又称复制缓冲区，是一个环形缓冲区，用于存储服务器执行过的命 令，每次传播命令，master都会将传播的命令记录下来，并存储在复制缓冲区，做备份作用\n​\t复制缓冲区默认数据存储空间大小是1M，由于存储空间大小是固定的，是一个环形数组\n●由来：每台服务器启动时，如果开启有AOF或被连接成为master节点，即创建复制缓冲区\n●作用：用于保存master收到的所有指令（仅影响数据变更的指令，例如set，select）\n●数据来源：当master接收到主客户端的指令时，除了将指令执行，会将该指令存储到缓冲区中\n  工作原理\n  注意：offset由谁来记录？\nslave必须要记录，因为从必须知道自己增量复制到哪里了\nmaster也要记录，因为当slave出现网络问题是，master和slave所记录的offset不一致，master再把slave丢失的数据重新复制\n 3、偏移量offset\n ●概念：一个数字，描述复制缓冲区中的指令字节位置\n● 分类：\n​\t● master复制偏移量：记录发送给所有slave的指令字节对应的位置（多个）\n​\t● slave复制偏移量：记录slave接收master发送过来的指令字节对应的位置（一个）\n●数据来源：\n​\tmaster端：发送一次记录一次\n​\tslave端：接收一次记录一次\n●作用：同步信息，比对master与slave的差异，当slave断线后，恢复数据使用\n replication buffer 和 rep_backlog_buffer 的区别 #  当主服务器进行命令传播的时候，maser不仅将所有的数据更新命令发送到所有slave的replication buffer，还会写入replication backlog。当断开的slave重新连接上master的时候，slave将会发送psync命令（包含复制的偏移量offset），请求partial resync。如果请求的offset不存在，那么执行全量的sync操作，相当于重新建立主从复制。\n这篇讲得比较清楚：https://mp.weixin.qq.com/s?__biz=MzkzMDI1NjcyOQ==\u0026amp;mid=2247487769\u0026amp;idx=1\u0026amp;sn=3c975ea118d4e59f72df5beed58f4768\u0026amp;source=41#wechat_redirect\n心跳机制 #    常见问题 #  频繁的全量复制 #  频繁的网路中断 #  数据不一致 #  哨兵模式 #   master宕机情况\n 简介 #  启用哨兵模式 #  哨兵工作原理 #   主从切换流程三个阶段\n 监控 #   用于同步各个节点的状态信息，通过info指令获取获取master的状态、slave、各个sentinel的状态（是否在线）\n  哨兵与master间通信 #   哨兵与master建立通信利用 master 提供发布/订阅机制发布自己的信息，再建立cmd连接，为了方便后期sentinel与master之间命令的交换\n 哨兵间相互发现 #   是哨兵通过info命令获取master的sentinels信息来得知在此哨兵之前是否有其他哨兵来监控\n 哨兵间相互通信 #   利用Redis的pub/sub发布/订阅机制，master 有一个 _sentinel_:hello 的专用通道，用于哨兵之间发布和订阅消息。这就好比是 _sentinel_:hello 微信群，哨兵利用 master 建立的微信群发布自己的消息，同时关注其他哨兵发布的消息。\n发布命令PUBLISH _sentinel_: hello，订阅命令SUBSCRIBE _sentinel_:hello\n 每个节点启动定时任务 #    第一个定时任务： 每个sentinel节点每隔1s向所有的master、slaver、别的sentinel节点发送一个PING命令，作用：心跳检测 第二个定时任务： 每个sentinel每隔2s都会向master的_sentinel_:hello通道中发送自己掌握的集群信息和自己的一些信息（比如host,ip,run id）作用：信息交换，了解别的sentinel的信息和他们对于主节点的判断 第三个定时任务： 每个sentinel节点每隔10s都会向master和slaver发送INFO命令，作用：发现最新的集群拓扑结构   通知 #  就是上面的第一个定时任务PING\n 故障转移 #   确认master客观下线 #  Leader选举 #  投票（一般配置票数quorum为哨兵数/2 + 1 ）确定master客观下线后，进行Leader 选举，投票选出这次执行主从切换的哨兵\n执行主从切换 #    新master上任，其他slave切换master，原master作为slave故障回复后连接\n Cluster模式 #  企业解决方案 #  "},{"id":10,"href":"/posts/redis/%E5%85%B3%E4%BA%8Eredis%E4%BA%8B%E5%8A%A1%E6%98%AF%E5%90%A6%E6%BB%A1%E8%B6%B3%E5%8E%9F%E5%AD%90%E6%80%A7/","title":"关于 Redis事务是否满足原子性","section":"博客","content":"个人理解这个问题需要分两种情况讨论\n multi开启事务后命令队列语法有错误或取消事务discard multi开启事务后命令队列运行错误  第一种情况 #   可以看到开启事务后输入一个错误语法命令get name zhangsan后立即显示错误提示了，再执行exec自然也是不行的，所有命令都不会执行。\ndiscard的情况就不用说了，取消事务。\n这种情况下是满足事务的原子性的，要不所有命令执行成功，要不一个命令都不执行。\n第二种情况 #  开启事务后命令语法正确，但是在命令执行期间出错，如输入参数的数据类型不符合命令的参数要求。\n set name后用了list的指令，可以看到命令执行后，能够正确运行的命令会执行，运行错误的命令不会被执行。这种情况下Redis 事务其实不满足原子性的，也就是Redis 不支持事务回滚机制，运行错误需要手动回滚(应该避免)。\n为什么Redis不支持回滚 #  官方文档说明：\n "},{"id":11,"href":"/posts/algorithm/kmp/","title":"KMP","section":"博客","content":"基本概念： #    非平凡前缀：包含首位字符但不包含末位字符的子串组合。\n  非平凡后缀：包含末位字符但不包含首位字符的子串组合。\n  next数组定义(又称部分匹配表)：模式串T j指针的变化(即当主串与模式串的某一位字符不匹配时，模式串要回退的位置)\n  next[j]的值：当前字符j之前(j-1位)的串的前后缀的相似度(重合字符数+1)\n  模式串求next数组 #  此教程面向的对象：\n 了解KMP算法原理，可以手写next数组 看过求next数组的代码，进行过相关思考  next[j]数组函数定义：\n 看懂求next数组代码最重要的是理解下面两句话：\n next[j+1]的最大值为next[j]+1 如果$P_{k1}\\neq P_{j}$ ,那么next[j+1]可能的最大值为next[next[j]]+1,以此类推即可高效求出next[j+1]。(重点)  ​\t第一句话的意思是，我们已知next[j]的情况下，继续与下一位字符匹配，最理想的情况就是下一位字符匹配依然相等$P_{k1}$= $P_{j}$，next[j+1]=next[j]+1,相似度+1\n​\t第二句话的意思是，我们已知**next[j]的情况下，继续与下一位字符匹配,匹配不相等（next[j]只是当前字符j之前的串的前后缀的相似度,然而决定回溯跨度**的是整个S串的前后缀的相似度），进行回溯，继续下一次匹配\n流程： ①求next[j+1],则已知next[1]、next[2]$\\cdots$next[j]\n②假设next[j]=$k_1$,则有$P_1\\cdots P_{k-1}$ = $P_{j-k+1}\\cdots P_{j-1}$(前k1-1位字符与后k1-1位字符重合)\n③如果$P_{k1}$= $P_{j}$,则$P_1\\cdots P_{k-1}P_{k1}$ = $P_{j-k+1}\\cdots P_{j-1}P_{j}$,则next[j+1]=k1+1,否则进入下一步\n④假设next[k1]=k2,则有$P_1\\cdots P_{k2-1}$ = $P_{k1-k2+1}\\cdots P_{k1-1}$\n⑤第二第三步联合得到：$P_1\\cdots P_{k2-1}$ = $P_{k1-k2+1}\\cdots P_{k1-1}$ = $P_{j-k1+1}\\cdots P_{k2-k1+j-1}$ = $P_{j-k2+1}\\cdots P_{j-1}$ 即四段 重合\n⑥这时候，再判断如果$P_{k2}$ = $P_{j}$, 则$P_1\\cdots P_{k2-1}P_{k2}$ = $P_{j-k2+1}\\cdots P_{j-1}P_{j}$ ,则next[j+1]=k2+1;否则 再取next[k2]=k3…以此类推\n图解：\n假设我们已知next[16] = 8 ,需要求next[17]\nnext[16] = 8 ,那么就是在j=16的字符前的串的前后缀有 8 -1 =7个字符重复\n 求next[17] 我们只需要比较$P_{8}$和$P_{16}$，最理想的情况就是$P_{8}$ = $P_{16}$ 那么next[17] = next[16]+1\n若$P_{8}$ ≠ $P_{16}$ ，k进行回溯，回溯到next[8] （我们假设next[8] = 4）\nnext[8] = 4 ,那么就是在j=4的字符前的串的前后缀有 4 -1 =3个字符重复\n 现在求next[17] 我们只需要比较$P_{4}$和$P_{16}$，第二理想情况就是$P_{4}$ = $P_{16}$ 那么next[17] = next[8]+1 = 5\n为什么呢\n因为蓝色部分相等，且橙色部分相等 ，那我们就可以推出四部分是相等的\n 如果第二理想情况都不满足，即$P_{4}$ ≠ $P_{16}$，k继续回溯，k = next[4] （我们假设next[4] = 2）\n 同理，若$P_{2}$ = $P_{16}$ 那么next[17] = next[4]+1 = 3\n否则，继续回溯，若回溯到next[1]=0,还不相等，则说明相似度为0，递推结束，双指针往后移一位，进行新一轮子串比较\n求next数组代码\nvoid getNext(string T,int* next){ \tint i = 1,k = 0;  next[1] = 0;  //T[0]代表模式串T的长度  while(i \u0026lt; T[0]){  if(k == 0 || T[i] == T[k]) next[++i] = ++k; //字符相同继续比较  else k = next[k]; //若字符不相同 k指针回溯  } } 举个例子：\n模式串：ababac\n先用一个例子来看代码的运行流程\n开始i指针指向1，k指针指向0，只有一个指针指向了字符，至少需要两个字符才能比较， 进入第一个if满足k == 0，next[++i] =++k,\ni,k指针都向前移一位\nnext[2] = 1；即j=2，在j之前只有一个字符，所以前后缀相似度为1\n i = 2 ，k = 1 T[2]不等于T[1] k指针回溯到next[k] 即next[1] = 0 ;\n 此时k又等于0了 满足if i，k指针都向前移一位，比较下一位\nnext[3] = 1\n i = 3 ， k = 1 T[3] = T[1] 满足if i ，k 指针继续后移\nnext[4] = 2\n i = 4 ，k = 2 T[4] = T[2] 满足if i，k指针继续后移\nnext[5] = 3\n i = 5，k = 3 T[5] = T[3] 满足if i，k指针继续后移\nnext[6] = 4 i = 6，k = 4 T[6] ≠ T[4] k指针开始回溯到next[k] =next[4] = 2\n i 不变，k = 2 T[6] ≠ T[2] k指针继续回溯到next[k] =next[2] = 1\n i 不变，k = 1 T[6] ≠ T[1] 这次匹配不成功则说明子串$P_{1}P_{2}P_{3}P_{4}P_{5}P_{6}$前后缀并不重复，于是k指针回溯到next[k] =next[1] = 0，进行i ，k指针后移比较下一个子串\n   我们再通过gif动画再来回顾一遍上面的流程：\n 主串和模式串的匹配 #  这一部分就比较简单\n代码\n//返回子串T在主串S中第pos字符之后的位置，若不存在则返回0 //代码需要根据自己的索引值更改循环的边界 int KMP(string S,string T,int pos){  int i = pos;  int j = 1;  int next[255];---------------------------1  getNext(T,next);-------------------------2   while(i \u0026lt;= S[0] \u0026amp;\u0026amp; j \u0026lt;= T[0]){  if(j == 0 || S[i] == T[i]){  ++i;  ++j;  }else{  j = next[j];---------------------3  }  }   if(j \u0026gt; T[0]) return i-T[0];  else return 0; } 下面看两个例子\n  通过上面两个例子也可以看出KMP算法仅当模式与主串之间存在许多“部分匹配”和模式串前后缀相似度小的情况下才能体现它的优势，否则和朴素模式匹配差异并不明显\n"},{"id":12,"href":"/posts/spring/%E5%85%B3%E4%BA%8E-responsebody-%E7%9A%84%E9%82%A3%E4%BA%9B%E4%BA%8B/","title":"关于 @ResponseBody 的那些事","section":"博客","content":"问题 #  用SpringBoot框架搭建的项目上写了一个新增用户的接口，接口地址是/v1/user/test，代码如下所示（demo版，非生产代码）。\n@Controller public class TestRespController { \t//新增用户的接口  @RequestMapping(\u0026#34;/v1/user/test\u0026#34;)  public User addUser(String userName, String password) {  User user = new User();  user.setUserName(userName);  user.setPassword(password);  return user;  } } 接口写好之后，启动项目开始调试代码，在chrome浏览器上输入了http://localhost:8080/v1/user/test这个地址，然后点击回车，没想到的是页面上提示了一个404的错误。\n 接口地址没有错，为什么找不到接口呢？奇了怪了。我火急火燎的跑到控制台，看看有没有错误日志。让我很失望啥错误都没有输出，过滤器也准确的把我的输入的请求地址打印出来了。\n 苦苦寻找 #  为啥页面报了404的错误，而控制台没有任何错误输出呢？实在是有点诡异。问同事嘛，又不好意思，自己好歹是个高级开发工程师，404的问题都搞不定实在是说不过去。三十六计走为上，看看其他的正常的接口是怎么写的。然后，我找到了这样一个接口，这个接口是可以正常访问的，\n@ResponseBody @RequestMapping(\u0026#34;/v1/user/test/update\u0026#34;) public User updateUser(User user) {  boolean result = testNgService.updateUser(user);  return result ? user : null; } 原因是没有在接口上添加@ResponseBody 注解，我印象中这个注解可以将返回的对象序列化成json字符串，并放在响应体中，但是跟接口地址又有什么关系呢？。抱着试试看的态度，我在接口上加上了 @ResponseBody注解，代码就不列举了，太简单了不好意思列举。再次访问http://localhost:8080/v1/user/test 这个地址，接口可以正常返回数据了。\n当然，如果该类下所有的接口都是返回application/json格式数据的接口，则可以直接将类上的**@Controller注解替换成 @RestController 注解。@RestController注解是一个组合注解是由@Controller注解和ResponseBody注解组成**。\n思考 #  至此，问题是解决了。\n 为啥页面报了404的错误，但是控制台没有错误日志呢？ 为啥不加@ResponseBody注解接口会报404的错误呢？  为什么页面报了404的错误，但是控制台没有错误日志呢？ #  为什么出现了404的异常，但是控制台没有错误的日志输出呢？这个就很奇怪了。这个问题是我们首先需要解决的，不然不知道具体的错误是啥，就很难定位到问题。根据已经掌握SpringMVC的知识：我们在页面输入一个url之后，请求首先会到DispatcherServlet。然后，DispatcherServlet会根据url去HandelMapping中找到能处理该请求的Handler。如果找不到的话则会报错404的错误，所以，猜测SpringBoot抛出的是NoHandlerFoundException这个异常，现在的问题就是为啥这个NoHandlerFoundException没输出呢？一番百度之后，我发现只需要在配置文件application.yml中添加如下配置即可：\nspring:  mvc: # 允许抛出NoHandlerFoundException  throw-exception-if-no-handler-found: true # 禁用资源映射  resources:  add-mappings: false 加上这两个配置之后，在访问接口的话，控制台就会打印出如下的错误日志：我们看到在查找mapping时url就变成了 /v1/user/v1/user/test，不是我们期待的 /v1/user/test。\n  说明：加上spring.resources.add-mappings=false 禁用资源映射之后，可以输出\n o.s.web.servlet.PageNotFound : No mapping for GET /v1/user/v1/user/test SpringBoot中的WebMvcAutoConfiguration类配置默认资源映射地址是 \u0026quot;/\u0026quot;\nprivate static final String SERVLET_LOCATION = \u0026#34;/\u0026#34;; 即使你的地址错误也会匹配到 /* 这个静态资源映射地址，就不会进入noHandlerFound方法，自然不会抛出NoHandlerFoundException了。 异常终于暴露出来了。接下来就是处理异常了。\n为什么不加@ResponseBody注解接口会报404的错误？ #  要想回答这个问题，还是要回到 @ResponseBody 注解的作用上面，一番苦苦的搜索之后，我终于发现了答案。@ResponseBody 注解的作用就是将Controller返回的对象通过适当的HttpMessageConverter转换为指定的格式，写入到Response对象的body数据区中返回给前端页面。如果没有加这个注解，只有@RequestMapping这个注解的话，则返回值通常解析为跳转路径，控制器返回的时候路径会变为（在当前路径的上一级路径上追加路径），然后返回的过程找不到对应的视图，导致404的错误。这只是理论，实际上是不是这样子的呢？还需要我们验证一下。\n不加@ResponseBody则默认会返回一个视图，如下图所示，返回一个名为 /static/helloWorld.html的视图。\n@RequestMapping(\u0026#34;/v1/user/test1\u0026#34;) public String queryUserHtml2() { \treturn \u0026#34;/static/helloWorld.html\u0026#34;; } 即会访问static目录下的helloWorld.html页面。\n 访问结果是：\n 页面可以正常的跳转，说明，不加上@ResponseBody注解确实会默认返回一个视图，这是正常的能找到页面的视图，如果返回一个不存在的视图会怎样呢？\n@RequestMapping(\u0026#34;/v1/user/test2\u0026#34;) public String queryUserHtml3() { \treturn \u0026#34;{\\\u0026#34;code\\\u0026#34;:200}\u0026#34;; } 打印出来的路径是 /v1/user/{“code”:200}，即/v1/user/test2的上级路径 /v1/user+{“code”:200}，说明上面的理论解释是没有问题的。\n总结 #  本文从实际开发中一个很小的问题入手，层层分析问题的根源，知其然更要知其所以然。总之，一句话总@ResponseBody注解的作用就是将返回的结果通过HttpMessageConverter 转换为指定格式并放在响应体中，没有它的话，SpringBoot会默认返回一个视图。\n"},{"id":13,"href":"/posts/spring/%E5%85%B3%E4%BA%8E%E4%BD%BF%E7%94%A8springdataredis%E9%85%8D%E7%BD%AE%E5%BA%8F%E5%88%97%E5%8C%96%E6%96%B9%E5%BC%8F%E6%97%B6%E6%8A%A5%E9%94%99/","title":"关于使用 SpringDataRedis 配置序列化方式时报错","section":"博客","content":"SpringBoot下RedisConfig配置\n/** * @author novo * @date 2022/1/2-22:13 */ @Configuration public class RedisConfig {  @Bean  public RedisTemplate\u0026lt;String,Object\u0026gt; redisTemplate(LettuceConnectionFactory lettuceConnectionFactory){  RedisTemplate\u0026lt;String, Object\u0026gt; redisTemplate = new RedisTemplate\u0026lt;\u0026gt;();  //为string类型的key设置序列化  redisTemplate.setKeySerializer(new StringRedisSerializer());  //为string类型的value设置序列化  redisTemplate.setValueSerializer(new GenericJackson2JsonRedisSerializer());  //redisTemplate.setValueSerializer(new Jackson2JsonRedisSerializer(Object.class));  //为hash设置序列化  redisTemplate.setHashKeySerializer(new StringRedisSerializer());  redisTemplate.setHashValueSerializer(new GenericJackson2JsonRedisSerializer());  // 设置 RedisConnection 工厂。 它就是实现多种 Java Redis 客户端接入的工厂  redisTemplate.setConnectionFactory(lettuceConnectionFactory);  return redisTemplate;  } } 报错信息\norg.springframework.data.redis.serializer.SerializationException: Could not read JSON: Cannot construct instance of `com.novo.springdataredis.pojo.User` (no Creators, like default constructor, exist):\rcannot deserialize from Object value (no delegate- or property-based Creator)\rCannot construct instance of `com.novo.springdataredis.pojo.User` (no Creators, like default constructor, exist): cannot deserialize from Object value (no delegate- or property-based Creator) 后面两行信息说的很清楚了\n就是pojo类的默认构造器不存在，也就是没有无参构造器，反序列化对象失败\n 简单来说JVM反序列化对象需要一个无参构造器\n网上一篇博客通过源码解析： 关于Java反序列化是否需要空参构造器\n复习一下 {% post_link Java/Java对象序列化反序列化 %}\n总结一下反序列化操作失败的几点原因\n 该类的序列版本号与从流中读取的类描述符的版本号不匹配 该类包含未知数据类型 该类没有可访问的无参数构造方法  "}]